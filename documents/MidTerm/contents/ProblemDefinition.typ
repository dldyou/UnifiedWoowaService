#let ProblemDefinition = [
= 핵심 문제 정의 및 해결 방안
== AS-IS 분석
=== AS-IS 모델
#align(center, image("img/as-is.svg", width: 70%))
=== 비즈니스 문제점
- 주문에 대한 배달을 수행할 때 주문, 배달, 결제 등의 기능을 맡는 주체가 달라서 서로에 대한 정보를 파악하기 힘들다.
- 기사에게 무작위적인 배달 요청 시에 배달 요청의 지연이 발생한다.
== TO-BE 분석
=== 비즈니스 비전
- 가게는 배민 통합 서비스를 통해 기사에게 배달을 요청하고, 기사는 수락할 수 있으며 고객은 배민 통합 서비스에서 배달 상황을 확인할 수 있다.
- 가게의 배달 요청이 지연되지 않도록 서비스에서 기사에게 우선 순위에 따라 배달을 요청한다.
=== TO-BE 모델
#align(center, image("img/to-be.svg", width: 50%))
== 기술적 문제 정의
=== 서비스 내 아키텍처 설계
*문제 정의*

각 서비스 ‘배민 서비스’, ‘결제 서비스’, ‘배달 대행 서비스’를 재사용성과 확장성을 고려하여 좋은 아키텍처를 설계할 수 있도록 한다. 

*해결 방안*

#align(center, image("img/service_architecture_structure.svg", width: 40%))
각 서비스는 계층 구조를 기반으로 한 3개의 계층 즉, 1계층(Controller, EventHandler), 2계층(Service), 3계층(Repository)으로 구성한다.

- 1계층: 외부 이벤트에 반응하여 필요한 기능 로직을 호출하는 계층이다. ‘배민 통합 서비스’에서 외부 이벤트는 사용자가 서비스를 이용할 수 있는 인터페이스인 CLI의 요청과 다른 서비스에서 publish 한 이벤트가 있다. 
- 2계층: 서비스 계층은 기능을 실행하기 위해 필요한 로직을 수행하는 계층이다. 
- 3계층: 레파지토리 계층에서는 데이터를 접근하고, 저장, 관리하는 계층이다. 
=== 서비스 간 통신
*문제 정의*

배민 통합 서비스는 ‘배민 서비스’, ‘결제 서비스’, ‘배달 대행 서비스’로 구성되어 있다. 따라서 각 서비스 작업의 결과가 다른 서비스를 호출하는 이벤트가 될 수 있다. 이를 위해 서비스에서 다른 서비스를 호출할 수 있는 방법이 필요하다. 

*해결 방안*

서비스에서 서비스를 호출하기 위해 타 서비스의 메서드를 직접 호출할 수 있을 것이다. 하지만 이는 서비스에서 다른 서비스를 의존하고, 서비스간 강결합이 발생한다. 좋은 객체 지향 설계를 위해서는 서비스간 loose-coupling을 지향할 필요가 있다. 

따라서 구글이 제공하는 Guava라이브러리의 EventBus를 활용한다. EventBus를 통해 호출하는 서비스에서 Event를 publish하고 호출되는 서비스에서 Event를 subscribe하여 서비스간 호출 로직을 제공한다.  

#align(center, image("img/entire_architecture_structure.svg", width: 100%))
=== 데이터의 동기화
*문제 정의*

각 서비스에는 여러 액터가 존재하기 때문에 같은 데이터를 접근, 수정할 수 있다. 해당 데이터에 대한 일관성을 유지하는 방법이 필요하다. 

*해결 방안*

본 프로젝트는 동시 접근에 대한 로직보다는 아키텍처의 설계와 서비스 간의 통신을 중점으로 한다. 따라서 서비스를 CLI형태로 제공하며 한가지의 액터만 서비스를 요청하는 순차적인 방식을 채택한다. 

=== 결제 방법의 다양성
*문제 정의*

사용자가 다양한 결제 수단(신용카드, 간편 결제 등)을 통해 결제를 진행할 수 있어야 한다.

*해결 방안*

인터페이스를 통해 공통 기능들을 추상화하여, 다양한 결제 수단들에 대해 기능을 확장할 수 있도록 설계한다.
]