#let ProblemDefinition = [
= 핵심 문제 정의 및 해결 방안
== 프로젝트 주제를 제안하게 된 계기, 기존의 문제 (AS-IS)
== 기술적 문제 정의
=== 서비스 내 아키텍처 설계
*문제 정의*

각 서비스 ‘배민 서비스’, ‘결제 서비스’, ‘배달 대행 서비스’를 재사용성과 확장성을 고려하여 좋은 아키텍처를 설계할 수 있도록 한다. 

*해결 방안*

#align(center, image("img/service_architecture_structure.svg", width: 40%))
각 서비스는 계층 구조를 기반으로 한 3개의 계층 즉, 1계층(Controller, EventHandler), 2계층(Service), 3계층(Repository)으로 구성한다.

- 1계층: 외부 이벤트에 반응하여 필요한 기능 로직을 호출하는 계층이다. ‘배민 통합 서비스’에서 외부 이벤트는 사용자가 서비스를 이용할 수 있는 인터페이스인 CLI의 요청과 다른 서비스에서 publish 한 이벤트가 있다. 
- 2계층: 서비스 계층은 기능을 실행하기 위해 필요한 로직을 수행하는 계층이다. 
- 3계층: 레파지토리 계층에서는 데이터를 접근하고, 저장, 관리하는 계층이다. 
=== 서비스 간 통신
*문제 정의*

배민 통합 서비스는 ‘배민 서비스’, ‘결제 서비스’, ‘배달 대행 서비스’로 구성되어 있다. 따라서 각 서비스 작업의 결과가 다른 서비스를 호출하는 이벤트가 될 수 있다. 이를 위해 서비스에서 다른 서비스를 호출할 수 있는 방법이 필요하다. 

*해결 방안*

서비스에서 서비스를 호출하기 위해 타 서비스의 메서드를 직접 호출할 수 있을 것이다. 하지만 이는 서비스에서 다른 서비스를 의존하고, 서비스간 강결합이 발생한다. 좋은 객체 지향 설계를 위해서는 서비스간 loose-coupling을 지향할 필요가 있다. 

따라서 구글이 제공하는 Guava라이브러리의 EventBus를 활용한다. EventBus를 통해 호출하는 서비스에서 Event를 publish하고 호출되는 서비스에서 Event를 subscribe하여 서비스간 호출 로직을 제공한다.  

#align(center, image("img/entire_architecture_structure.svg", width: 100%))
=== 데이터의 동기화
*문제 정의*

각 서비스에는 여러 액터가 존재하기 때문에 같은 데이터를 접근, 수정할 수 있다. 해당 데이터에 대한 일관성을 유지하는 방법이 필요하다. 

*해결 방안*

본 프로젝트는 동시 접근에 대한 로직보다는 아키텍처의 설계와 서비스 간의 통신을 중점으로 한다. 따라서 서비스를 CLI형태로 제공하며 한가지의 액터만 서비스를 요청하는 순차적인 방식을 채택한다. 

=== 결제 방법의 다양성
*문제 정의*

사용자가 다양한 결제 수단(신용카드, 간편 결제 등)을 통해 결제를 진행할 수 있어야 한다.

*해결 방안*

인터페이스를 통해 공통 기능들을 추상화하여, 다양한 결제 수단들에 대해 기능을 확장할 수 있도록 설계한다.
== 그 문제를 어떻게 해결할지 본인들이 접근 방법 설명 (TO-BE)
]